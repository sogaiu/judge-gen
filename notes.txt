# LIMITS:
#
# * tends to work for direct subdirectories of the project directory.
#   files can be in deeper directories, but for least hassle, point
#   configuration information at direct subdirectories of project
#   directory.
#
# * doesn't clean up temporary files and directories automatically
#
# * doesn't handle edge case of two comments lines in a row that
#   look like expected value lines
#
# * updating an existing judge-gen installation has the downside of
#   potentially erasing previous configuration information.
#
# * likely only works with utf-8

# POSSIBILITIES:
#
# * document the limitation about direct subdirectories of the project
#   directory and the "why".  a direct subdirectory of the project directory
#   has at least the following important properties:
#   * copying the content (contained files and directories) to a sibling
#     directory (one that is also a direct subdirectory of the
#     project directory) doesn't adversely affect most likely (tm)
#     paths in import forms.  at least so far, the probability of
#     the imports still working after copying seems pretty high.
#     one pathological case is an import with the path of the form
#     "../name-a/name-b", where the import is in a file which lives in
#     a directory with name "name-a".  things like this are likely to
#     not work with judge-gen's copying scheme.  it seems unlikely to
#     be a problem though because why wouldn't one express the path
#     like "./name-b" instead?
#   * copying the content (contained files and directories) to a sibling
#     directory also doesn't "leave behind" files and directories that might
#     be necessary for imports to work correctly.  if a non-direct
#     subdirectory of the project directory is specified, there is a chance
#     its content will refer to a sibling's content (which would also be a
#     non-direct subdirectory of the project directory), and judge-gen's
#     copying scheme would fail for this case.
#   if these two points are not issues for one's use case, it may be
#   that one can use a non-direct subdirectory of the project directory
#   (i.e. a "deeper" subdirectory) in the configuration of judge-gen.
#
# * audit code for use of stdout vs stderr - likely not consistent
#
# * configuration ideas
#   * motivation for configuration via external file
#     * current method risks losing configuration information upon upgrade
#     * current method leads to likelihood of having to edit
#       test/judge-gen.janet on each upgrade (tedious and error-prone?)
#     * current method risks breaking test/judge-gen.janet because a user
#       typically has to edit it at least once
#   * each runner in test should have a unique name that can be used
#     to look up configuration info in jg.jdn.  if there is no jg.jdn, then
#     the name of the file specifies a subdirectory of the project directory.
#     this last bit helps make it possible for the config file is optional
#     for some cases.
#   * can use one judge-gen.janet per directory of source files, but that
#     would lead to multiple judge-gen.janet files.  perhaps an alternative
#     is to have a single configuration file that could "drive" judge-gen.janet
#     to be used for multple directories.  need to consider multiple
#     judge directories to prevent collisions?
#
# * consider if there is any benefit in allowing some control over
#   test file execution order, e.g.
#   * sort by name
#   * sort by other criteria
#   * random
#   * custom order
#
# * _verify/dump-results uses "%p" in a branch.  could that be a problem
#   in some cases?
#
# * downside of using `(deep= A B)` with expected value of true is
#   when the test fails, there's not a whole lot of useful information
#   apart from the failure.  is this just a trade-off that has to be
#   made with the current approach?  there is a way to write things
#   that avoids this, but that method requires writing a `def` before
#   the expression to be evaluated and then using the name of the
#   `def` as the expected value.
#
# * consider various "rewriting" targets, e.g. testament, helper.janet
#   for "transition" purposes
#
# * in handle_one, instead of `(break false)`, perhaps different
#   values could be returned to indicate different types of errors
#
# * consider different reporting modes for jg.  concrete examples:
#
#   * for earliest / quickest feedback, have _verify output info as soon
#     as it is available
#
#   * for slower feedback, have _verify just pass back all test
#     results at the end when they are all ready
#
#   different receivers might be set up for handling test results, but
#   this may be getting too elaborate at this stage :)
#
# * produce code with comment blocks unwrapped inline -- test context is
#   is more likely to be correct than just appending tests after original
#   code
#
# * would using recent janet-peg for parsing as well as rewriting
#   source be any better than the current approach?
#   * possibly easier to transform and output?
#   * possibly easier to determine line / column info for tests?
#   * examine alc.x-as-tests for hints

# ISSUES:
#
# * how to handle rather large return values -- load from external file?
#
# * how / whether to try to test output (such as from `print`) -- see
#   spork's `capture-stdout` for an idea
#
# * consider using :s instead of :ws in pegs, also in janet-peg-grammar

# QUESTIONS:
#
# * where to document usage of temporary directory to store test results and
#   output?
#
# * provide a mode to work on stuff outside a comment block?
#
#   so for example the following at the top-level:
#
#     (def a 1)
#     # => 1
#
#   ought to work?
